# GPGPU架构

## GPGPU控制核心架构

### 记分牌

#### CPU与GPGPU中的数据依赖

与CPU一样，指令之间的数据依赖会对流水线的指令级并行产生影响。

简单复习一下三种数据依赖：

* 写后读（Read After Write，RAW）：真数据依赖
* 写后写（Write After Write，WAW）：输出依赖（名称依赖）
* 读后写（Write After Read，WAR）：反依赖

在CPU中，通过寄存器重命名可以解决输出依赖（WRW）和反依赖（WAR）这两种由寄存器名冲突而非真实数据传递引起的数据依赖，而真数据依赖则可以通过记分牌和Tomasulo算法检测和规避。

但GPU寄存器和功能单元数量众多，记分牌和Tomasulo算法的复杂度和硬件开销是GPU无法接受的，大量连线的成本也不容忽视。

另一方面，相较于CPU需要利用乱序执行来提高指令级并行度，GPGPU的SIMT架构指令并行度本就很高，且寄存器数量足以支持**零开销线程切换**，即使某个线程束由于数据依赖而导致停顿，线程束调度器也可以从其他线程束中找到合适的指令填充流水线，降低数据依赖对流水线性能的影响。

因此，GPGPU一般会采用warp内顺序执行、warp间乱序执行的方式来提高SIMT运算单元的硬件效率，避免乱序流水线带来的指令管理开销。但GPGPU流水线仍然需要对数据依赖进行检测和处理以保证执行结果的正确性。

#### GPGPU中的记分牌

相比CPU乱序执行流水线的记分牌需要记录功能单元（结构冒险）和寄存器（WAR、WAW）是否可用以及指令的输入数据可以从哪个功能单元旁路获取（RAW）来提高**单线程发射吞吐**，GPGPU的顺序流水线只需简单地记录功能单元和寄存器是否可用来决定是否阻塞指令的发射，通过零开销线程切换来保证**多线程发射吞吐**。

下面来探讨一下如何记录寄存器是否可用：

最简单的方式是为每个线程束寄存器分配1bit用于记录相应寄存器的的可用状态，后续存在数据依赖的指令只有当该寄存器可用时才能发射。

但这种方案存在两个问题：

* GPGPU中存在大量寄存器，给每个寄存器都分配1bit将占用大量的空间；
* 所有待发射的线程束指令在调度时需要一直查询记分牌，假设每个SM最高支持64个warp，每个warp最多访问4个操作数，那么记分牌需要提供256个端口给线程束调度器才能支持同时检查所有warp的数据依赖，会带来巨大的硬件开销。

以下是两种可行的优化方案：

##### 基于寄存器编号索引的记分牌

该方法来源于NVIDIA的一项专利。

由于记分牌主要是对指令缓冲中已解码的指令进行相关性检查，因此可以分配与指令缓冲中指令数目相同的

##### 基于读写屏障的软件记分牌
